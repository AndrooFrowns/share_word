// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createPuzzle = `-- name: CreatePuzzle :one
INSERT INTO puzzles (id, owner_id, name, width, height)
VALUES (?, ?, ?, ?, ?)
RETURNING id, owner_id, name, width, height, created_at, updated_at
`

type CreatePuzzleParams struct {
	ID      string
	OwnerID string
	Name    string
	Width   int64
	Height  int64
}

func (q *Queries) CreatePuzzle(ctx context.Context, arg CreatePuzzleParams) (Puzzle, error) {
	row := q.db.QueryRowContext(ctx, createPuzzle,
		arg.ID,
		arg.OwnerID,
		arg.Name,
		arg.Width,
		arg.Height,
	)
	var i Puzzle
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Width,
		&i.Height,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, username, password_hash, created_at)
VALUES (?, ?, ?, ?)
RETURNING id, username, password_hash, created_at
`

type CreateUserParams struct {
	ID           string
	Username     string
	PasswordHash string
	CreatedAt    time.Time
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.Username,
		arg.PasswordHash,
		arg.CreatedAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAllCells = `-- name: DeleteAllCells :exec
DELETE FROM cells WHERE puzzle_id = ?
`

func (q *Queries) DeleteAllCells(ctx context.Context, puzzleID string) error {
	_, err := q.db.ExecContext(ctx, deleteAllCells, puzzleID)
	return err
}

const deleteAllClues = `-- name: DeleteAllClues :exec
DELETE FROM clues WHERE puzzle_id = ?
`

func (q *Queries) DeleteAllClues(ctx context.Context, puzzleID string) error {
	_, err := q.db.ExecContext(ctx, deleteAllClues, puzzleID)
	return err
}

const deleteCellsOutside = `-- name: DeleteCellsOutside :exec
DELETE FROM cells WHERE puzzle_id = ? AND (x >= ? OR y >= ?)
`

type DeleteCellsOutsideParams struct {
	PuzzleID string
	X        int64
	Y        int64
}

func (q *Queries) DeleteCellsOutside(ctx context.Context, arg DeleteCellsOutsideParams) error {
	_, err := q.db.ExecContext(ctx, deleteCellsOutside, arg.PuzzleID, arg.X, arg.Y)
	return err
}

const followUser = `-- name: FollowUser :exec
INSERT INTO follows (follower_id, followed_id)
VALUES (?, ?)
`

type FollowUserParams struct {
	FollowerID string
	FollowedID string
}

func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) error {
	_, err := q.db.ExecContext(ctx, followUser, arg.FollowerID, arg.FollowedID)
	return err
}

const getCells = `-- name: GetCells :many
SELECT puzzle_id, x, y, char, is_block, is_pencil, solution FROM cells WHERE puzzle_id = ? ORDER BY y, x
`

func (q *Queries) GetCells(ctx context.Context, puzzleID string) ([]Cell, error) {
	rows, err := q.db.QueryContext(ctx, getCells, puzzleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cell
	for rows.Next() {
		var i Cell
		if err := rows.Scan(
			&i.PuzzleID,
			&i.X,
			&i.Y,
			&i.Char,
			&i.IsBlock,
			&i.IsPencil,
			&i.Solution,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClues = `-- name: GetClues :many
SELECT puzzle_id, number, direction, text FROM clues WHERE puzzle_id = ?
`

func (q *Queries) GetClues(ctx context.Context, puzzleID string) ([]Clue, error) {
	rows, err := q.db.QueryContext(ctx, getClues, puzzleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Clue
	for rows.Next() {
		var i Clue
		if err := rows.Scan(
			&i.PuzzleID,
			&i.Number,
			&i.Direction,
			&i.Text,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowers = `-- name: GetFollowers :many
SELECT u.id, u.username, u.password_hash, u.created_at FROM users u
JOIN follows f on u.id = f.follower_id
WHERE f.followed_id = ?
ORDER BY f.created_at DESC
LIMIT ? OFFSET ?
`

type GetFollowersParams struct {
	FollowedID string
	Limit      int64
	Offset     int64
}

func (q *Queries) GetFollowers(ctx context.Context, arg GetFollowersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getFollowers, arg.FollowedID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.PasswordHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowing = `-- name: GetFollowing :many
SELECT u.id, u.username, u.password_hash, u.created_at FROM users u
JOIN follows f on u.id = f.followed_id
WHERE f.follower_id = ?
ORDER BY f.created_at DESC
LIMIT ? OFFSET ?
`

type GetFollowingParams struct {
	FollowerID string
	Limit      int64
	Offset     int64
}

func (q *Queries) GetFollowing(ctx context.Context, arg GetFollowingParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getFollowing, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.PasswordHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastPuzzleByOwner = `-- name: GetLastPuzzleByOwner :one
SELECT id, owner_id, name, width, height, created_at, updated_at FROM puzzles
WHERE owner_id = ?
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLastPuzzleByOwner(ctx context.Context, ownerID string) (Puzzle, error) {
	row := q.db.QueryRowContext(ctx, getLastPuzzleByOwner, ownerID)
	var i Puzzle
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Width,
		&i.Height,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPuzzle = `-- name: GetPuzzle :one
SELECT p.id, p.owner_id, p.name, p.width, p.height, p.created_at, p.updated_at, u.username as owner_username FROM puzzles p
JOIN users u ON u.id = p.owner_id
WHERE p.id = ? LIMIT 1
`

type GetPuzzleRow struct {
	ID            string
	OwnerID       string
	Name          string
	Width         int64
	Height        int64
	CreatedAt     time.Time
	UpdatedAt     sql.NullTime
	OwnerUsername string
}

func (q *Queries) GetPuzzle(ctx context.Context, id string) (GetPuzzleRow, error) {
	row := q.db.QueryRowContext(ctx, getPuzzle, id)
	var i GetPuzzleRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Width,
		&i.Height,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OwnerUsername,
	)
	return i, err
}

const getPuzzlesByOwner = `-- name: GetPuzzlesByOwner :many
SELECT p.id, p.owner_id, p.name, p.width, p.height, p.created_at, p.updated_at, u.username as owner_username FROM puzzles p
JOIN users u ON u.id = p.owner_id
WHERE p.owner_id = ? ORDER BY p.created_at DESC LIMIT ? OFFSET ?
`

type GetPuzzlesByOwnerParams struct {
	OwnerID string
	Limit   int64
	Offset  int64
}

type GetPuzzlesByOwnerRow struct {
	ID            string
	OwnerID       string
	Name          string
	Width         int64
	Height        int64
	CreatedAt     time.Time
	UpdatedAt     sql.NullTime
	OwnerUsername string
}

func (q *Queries) GetPuzzlesByOwner(ctx context.Context, arg GetPuzzlesByOwnerParams) ([]GetPuzzlesByOwnerRow, error) {
	rows, err := q.db.QueryContext(ctx, getPuzzlesByOwner, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPuzzlesByOwnerRow
	for rows.Next() {
		var i GetPuzzlesByOwnerRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.Width,
			&i.Height,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPuzzlesFromFollowing = `-- name: GetPuzzlesFromFollowing :many
SELECT p.id, p.owner_id, p.name, p.width, p.height, p.created_at, p.updated_at FROM puzzles p
JOIN follows f ON f.followed_id = p.owner_id
WHERE f.follower_id = ?
ORDER BY p.created_at DESC LIMIT ? OFFSET ?
`

type GetPuzzlesFromFollowingParams struct {
	FollowerID string
	Limit      int64
	Offset     int64
}

func (q *Queries) GetPuzzlesFromFollowing(ctx context.Context, arg GetPuzzlesFromFollowingParams) ([]Puzzle, error) {
	rows, err := q.db.QueryContext(ctx, getPuzzlesFromFollowing, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Puzzle
	for rows.Next() {
		var i Puzzle
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.Width,
			&i.Height,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPuzzlesFromFollowingWithUsername = `-- name: GetPuzzlesFromFollowingWithUsername :many
SELECT p.id, p.owner_id, p.name, p.width, p.height, p.created_at, p.updated_at, u.username as owner_username FROM puzzles p
JOIN follows f ON f.followed_id = p.owner_id
JOIN users u ON u.id = p.owner_id
WHERE f.follower_id = ?
ORDER BY p.created_at DESC LIMIT ? OFFSET ?
`

type GetPuzzlesFromFollowingWithUsernameParams struct {
	FollowerID string
	Limit      int64
	Offset     int64
}

type GetPuzzlesFromFollowingWithUsernameRow struct {
	ID            string
	OwnerID       string
	Name          string
	Width         int64
	Height        int64
	CreatedAt     time.Time
	UpdatedAt     sql.NullTime
	OwnerUsername string
}

func (q *Queries) GetPuzzlesFromFollowingWithUsername(ctx context.Context, arg GetPuzzlesFromFollowingWithUsernameParams) ([]GetPuzzlesFromFollowingWithUsernameRow, error) {
	rows, err := q.db.QueryContext(ctx, getPuzzlesFromFollowingWithUsername, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPuzzlesFromFollowingWithUsernameRow
	for rows.Next() {
		var i GetPuzzlesFromFollowingWithUsernameRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.Width,
			&i.Height,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, username, password_hash, created_at FROM users WHERE id = ? LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password_hash, created_at FROM users WHERE username = ? LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const importCell = `-- name: ImportCell :exec
INSERT INTO cells (puzzle_id, x, y, char, is_block, is_pencil, solution)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(puzzle_id, x, y) DO UPDATE SET
    char = excluded.char,
    solution = excluded.solution,
    is_block = excluded.is_block,
    is_pencil = excluded.is_pencil
`

type ImportCellParams struct {
	PuzzleID string
	X        int64
	Y        int64
	Char     string
	IsBlock  bool
	IsPencil bool
	Solution string
}

func (q *Queries) ImportCell(ctx context.Context, arg ImportCellParams) error {
	_, err := q.db.ExecContext(ctx, importCell,
		arg.PuzzleID,
		arg.X,
		arg.Y,
		arg.Char,
		arg.IsBlock,
		arg.IsPencil,
		arg.Solution,
	)
	return err
}

const isFollowing = `-- name: IsFollowing :one
SELECT EXISTS (
    SELECT 1 FROM follows
    WHERE follower_id = ? AND followed_id = ?
)
`

type IsFollowingParams struct {
	FollowerID string
	FollowedID string
}

func (q *Queries) IsFollowing(ctx context.Context, arg IsFollowingParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isFollowing, arg.FollowerID, arg.FollowedID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const toggleBlock = `-- name: ToggleBlock :exec
UPDATE cells 
SET is_block = NOT is_block, char = '' 
WHERE puzzle_id = ? AND x = ? AND y = ?
`

type ToggleBlockParams struct {
	PuzzleID string
	X        int64
	Y        int64
}

func (q *Queries) ToggleBlock(ctx context.Context, arg ToggleBlockParams) error {
	_, err := q.db.ExecContext(ctx, toggleBlock, arg.PuzzleID, arg.X, arg.Y)
	return err
}

const unfollowUser = `-- name: UnfollowUser :exec
DELETE FROM follows
WHERE follower_id = ? AND followed_id = ?
`

type UnfollowUserParams struct {
	FollowerID string
	FollowedID string
}

func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) error {
	_, err := q.db.ExecContext(ctx, unfollowUser, arg.FollowerID, arg.FollowedID)
	return err
}

const updateCell = `-- name: UpdateCell :exec
INSERT INTO cells (puzzle_id, x, y, char, is_block, is_pencil, solution)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(puzzle_id, x, y) DO UPDATE SET
    char = excluded.char,
    is_block = excluded.is_block,
    is_pencil = excluded.is_pencil
`

type UpdateCellParams struct {
	PuzzleID string
	X        int64
	Y        int64
	Char     string
	IsBlock  bool
	IsPencil bool
	Solution string
}

func (q *Queries) UpdateCell(ctx context.Context, arg UpdateCellParams) error {
	_, err := q.db.ExecContext(ctx, updateCell,
		arg.PuzzleID,
		arg.X,
		arg.Y,
		arg.Char,
		arg.IsBlock,
		arg.IsPencil,
		arg.Solution,
	)
	return err
}

const updatePuzzleDimensions = `-- name: UpdatePuzzleDimensions :exec
UPDATE puzzles SET width = ?, height = ? WHERE id = ?
`

type UpdatePuzzleDimensionsParams struct {
	Width  int64
	Height int64
	ID     string
}

func (q *Queries) UpdatePuzzleDimensions(ctx context.Context, arg UpdatePuzzleDimensionsParams) error {
	_, err := q.db.ExecContext(ctx, updatePuzzleDimensions, arg.Width, arg.Height, arg.ID)
	return err
}

const updatePuzzleUpdatedAt = `-- name: UpdatePuzzleUpdatedAt :exec
UPDATE puzzles SET updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) UpdatePuzzleUpdatedAt(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updatePuzzleUpdatedAt, id)
	return err
}

const upsertClue = `-- name: UpsertClue :exec
INSERT INTO clues (puzzle_id, number, direction, text)
VALUES (?, ?, ?, ?)
ON CONFLICT(puzzle_id, number, direction) DO UPDATE SET
    text = excluded.text
`

type UpsertClueParams struct {
	PuzzleID  string
	Number    int64
	Direction string
	Text      string
}

func (q *Queries) UpsertClue(ctx context.Context, arg UpsertClueParams) error {
	_, err := q.db.ExecContext(ctx, upsertClue,
		arg.PuzzleID,
		arg.Number,
		arg.Direction,
		arg.Text,
	)
	return err
}
